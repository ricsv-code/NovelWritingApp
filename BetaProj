        public class ExtendedKalmanFilter
        {
            private double _state; // Tillstånd (t.ex. position)
            private double _errorCovariance; // Felkovarians (osäkerhet i tillståndet)
            private readonly double _processNoise;
            private readonly double _measurementNoise;

            public ExtendedKalmanFilter(double initialState, double initialErrorCovariance, double processNoise, double measurementNoise)
            {
                _state = initialState;
                _errorCovariance = initialErrorCovariance;
                _processNoise = processNoise;
                _measurementNoise = measurementNoise;
            }

            public Func<double, double>  ProcessModel { get; set; }

            // Icke-linjär processmodell (exempel med en sinusfunktion)
            private double ProcessModel(double state)
            {
                return Math.Sin(state);
            }

            // Derivatan av processmodellen (används som Jacobian)
            private double ProcessModelJacobian(double state)
            {
                return Math.Cos(state); // Derivatan av sin(x) är cos(x)
            }

            // Mätmodell (vi antar att mätningen är linjär här, men den kan också vara icke-linjär)
            private double MeasurementModel(double state)
            {
                return state; //sensor input
            }

            // Derivatan av mätmodellen (Jacobian)
            private double MeasurementModelJacobian(double state)
            {
                return 1.0; // Derivatan av en linjär funktion är konstant
            }

            public double Update(double measurement)
            {
                // Förutsägelse
                double predictedState = ProcessModel(_state);
                double jacobianProcessModel = ProcessModelJacobian(_state);
                double predictedErrorCovariance = jacobianProcessModel * _errorCovariance * jacobianProcessModel + _processNoise;

                // Kalman Gain
                double jacobianMeasurementModel = MeasurementModelJacobian(predictedState);
                double kalmanGain = predictedErrorCovariance * jacobianMeasurementModel /
                                    (jacobianMeasurementModel * predictedErrorCovariance * jacobianMeasurementModel + _measurementNoise);

                // Uppdatering med mätningen
                _state = predictedState + kalmanGain * (measurement - MeasurementModel(predictedState));
                _errorCovariance = (1 - kalmanGain * jacobianMeasurementModel) * predictedErrorCovariance;

                return _state;
            }
