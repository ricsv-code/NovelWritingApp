using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using System.Globalization;

namespace PlateauDetect
{

    public class Vector2D
    {
        public double X { get; set; }
        public double Y { get; set; }

        public Vector2D(double x, double y)
        {
            X = x;
            Y = y;
        }
    }

    public static class DataTransform
    {
        private static double _previousSwAngle;
        private static double _totalSwRotation;
        private static TimeSpan _maxTimeDifference;
        private static Queue<(TimeSpan time, double value)> _swQueue = new Queue<(TimeSpan time, double value)>();
        private static Queue<(TimeSpan time, double value)> _wheelQueue = new Queue<(TimeSpan time, double value)>();

        private static double? _refSwVal;
        private static double? _refWheelVal;

        static DataTransform()
        {
            TimeSpan maxTimeDifference = new TimeSpan(0, 0, 2);
            _previousSwAngle = 0;
            _totalSwRotation = 0;
            _maxTimeDifference = maxTimeDifference;

            _refSwVal = null;
            _refWheelVal = null;
        }

        public static void UpdateSwAngle(double inclY, double inclZ, TimeSpan timestamp)
        {
            double currentAngle = Math.Atan2(inclY, inclZ);

            if (_refSwVal == null)
            {
                _refSwVal = currentAngle;
            }

            double deltaAngle = currentAngle - _refSwVal.Value;

            if (deltaAngle > Math.PI)
            {
                deltaAngle -= 2 * Math.PI;
            }
            else if (deltaAngle < -Math.PI)
            {
                deltaAngle += 2 * Math.PI;
            }

            _totalSwRotation += deltaAngle;
            _previousSwAngle = currentAngle;

            _swQueue.Enqueue((timestamp, _totalSwRotation));

            TryMatchValues();
        }

        public static void UpdateWheelAngle(double wheelAngle, TimeSpan timestamp)
        {
            if (_refWheelVal == null)
            {
                _refWheelVal = wheelAngle;
            }

            double wheelRotation = Math.Abs(_refWheelVal.Value - wheelAngle);

            _wheelQueue.Enqueue((timestamp, wheelRotation));

            TryMatchValues();
        }

        private static void TryMatchValues()
        {
            while (_swQueue.Count > 0 && _wheelQueue.Count > 0)
            {
                var sw = _swQueue.Peek();
                var wheel = _wheelQueue.Peek();
                var timeDifference = Math.Abs((sw.time - wheel.time).TotalMilliseconds);

                if (timeDifference <= _maxTimeDifference.TotalMilliseconds)
                {
                    Vector2D matchedPoint = ProcessMatch(sw.value, wheel.value);

                    _swQueue.Dequeue();
                    _wheelQueue.Dequeue();

                    OnDataMatched?.Invoke(null, matchedPoint);
                }
                else
                {
                    if (sw.time < wheel.time)
                    {
                        _swQueue.Dequeue();
                    }
                    else
                    {
                        _wheelQueue.Dequeue();
                    }
                }
            }
        }

        public static event EventHandler<Vector2D> OnDataMatched;

        private static Vector2D ProcessMatch(double swValue, double wheelValue)
        {
            return new Vector2D(swValue, wheelValue);
        }
    }
}




using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Windows.Media.Imaging;
using System.Globalization;

namespace PlateauDetect
{
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class MainWindow : Window
    {
        private string _dataPath;
        public MainWindow()
        {
            InitializeComponent();

            _dataPath = "C:\\Users\\Rille\\source\\repos\\PlateauDetect\\MockupData.txt";


            Plateau.OnPointAdded += (sender, e) =>
            {
                Dispatcher.Invoke(() =>
                {
                    var image = PlotGraph(e);
                    Plot.Source = image;
                });

            };
        }


        private async void ADButton_Click(object sender, RoutedEventArgs e)
        {
            await Task.Run(() => AquireData(_dataPath));
        }

        public static async Task AquireData(string dataPath)
        {
            foreach (var line in File.ReadAllLines(dataPath))
            {
                var s = line.Split('\t');

                DataTransform.UpdateSwAngle(double.Parse(s[1], CultureInfo.InvariantCulture), double.Parse(s[2], CultureInfo.InvariantCulture), TimeSpan.Parse(s[0], CultureInfo.InvariantCulture));
                DataTransform.UpdateWheelAngle(double.Parse(s[4], CultureInfo.InvariantCulture), TimeSpan.Parse(s[3], CultureInfo.InvariantCulture));

                await Task.Delay(300);
            }

            //OnSwSignalReceived += DataTransform.UpdateSwAngle(double.Parse(s[1], CultureInfo.InvariantCulture), double.Parse(s[2], CultureInfo.InvariantCulture), TimeSpan.Parse(s[0], CultureInfo.InvariantCulture));
            //OnWheelSignalReceived +=DataTransform.UpdateWheelAngle(double.Parse(s[4], CultureInfo.InvariantCulture), TimeSpan.Parse(s[3], CultureInfo.InvariantCulture));
        }



        public BitmapImage PlotGraph(List<Vector2D> points, int width = 800, int height = 600)
        {

            using (Bitmap bitmap = new Bitmap(width, height))
            {
                using (Graphics g = Graphics.FromImage(bitmap))
                {
                    g.Clear(System.Drawing.Color.White);

                    Pen axisPen = new Pen(Color.Black, 2);
                    Brush pointBrush = Brushes.Red;

                    g.DrawLine(axisPen, 40, height - 40, width - 40, height - 40); // X-axeln
                    g.DrawLine(axisPen, 40, 40, 40, height - 40); // Y-axeln

                    double minX = Double.MaxValue, maxX = Double.MinValue;
                    double minY = Double.MaxValue, maxY = Double.MinValue;

                    foreach (var point in points)
                    {
                        if (point.X < minX) minX = point.X;
                        if (point.X > maxX) maxX = point.X;
                        if (point.Y < minY) minY = point.Y;
                        if (point.Y > maxY) maxY = point.Y;
                    }

                    double margin = 2;
                    minX -= margin;
                    maxX += margin;
                    minY -= margin;
                    maxY += margin;

                    float ScaleX(double x) => (float)((x - minX) / (maxX - minX) * (width - 80) + 40);
                    float ScaleY(double y) => (float)((height - 40) - (y - minY) / (maxY - minY) * (height - 80));

                    foreach (var point in points)
                    {
                        float x = ScaleX(point.X);
                        float y = ScaleY(point.Y);

                        g.FillEllipse(pointBrush, x - 3, y - 3, 6, 6);
                    }
                }

                using (MemoryStream memoryStream = new MemoryStream())
                {
                    bitmap.Save(memoryStream, ImageFormat.Png);
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    BitmapImage bitmapImage = new BitmapImage();
                    bitmapImage.BeginInit();
                    bitmapImage.CacheOption = BitmapCacheOption.OnLoad;
                    bitmapImage.StreamSource = memoryStream;
                    bitmapImage.EndInit();

                    return bitmapImage;
                }
            }
        }

    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace PlateauDetect
{
    public static class Plateau
    {

        static Plateau()
        {
            DataTransform.OnDataMatched += (sender, point) =>
            {
                AddPoint(point);
            };

        }


        private static List<Vector2D> _points = new List<Vector2D>();


        public static void AddPoint(Vector2D point)
        {
            if (_points.Count == 0 || Math.Abs(point.X - _points.Last().X) >= 0.1)
            {
                _points.Add(point);
                OnPointAdded?.Invoke(null, _points);
            }

        }

        public static event EventHandler<List<Vector2D>> OnPointAdded;


    }
}

