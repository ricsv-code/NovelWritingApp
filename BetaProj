public class PlateauDetector : IPlateauDetector
{
    public double MinPlateauLength { get; set; }
    public double PlateauStartMinX { get; set; }
    public double PlateauMinY { get; set; }
    public bool XFlipped { get; set; }
    public bool YFlipped { get; set; }

    private List<Vector2> _points;
    private Vector2 _currentPlateauStart;

    public PlateauDetector()
    {
        _points = new List<Vector2>();
        _currentPlateauStart = Vector2.Zero;
    }

    public bool Update(Vector2 newPoint, out Vector2 startOfPlateau)
    {
        // Lägg till den nya punkten till listan av punkter
        _points.Add(newPoint);

        // Om vi har tillräckligt många punkter, beräkna kovariansen
        if (_points.Count >= 2)
        {
            double covariance = CalculateCovariance(_points);

            // Kontrollera om kovariansen är nära noll, vilket skulle indikera en platå
            if (Math.Abs(covariance) < 0.001) // Threshold för att detektera platå
            {
                // Kontrollera om x-intervallet är tillräckligt stort för att vara en platå
                if (Math.Abs(_points.Last().X - _points.First().X) >= MinPlateauLength &&
                    _points.First().X >= PlateauStartMinX &&
                    _points.All(p => p.Y >= PlateauMinY))
                {
                    startOfPlateau = _currentPlateauStart = _points.First();
                    return true;
                }
            }
        }

        startOfPlateau = Vector2.Zero;
        return false;
    }

    public void Reset()
    {
        _points.Clear();
        _currentPlateauStart = Vector2.Zero;
    }

    private double CalculateCovariance(List<Vector2> points)
    {
        int n = points.Count;
        double meanX = points.Average(p => p.X);
        double meanY = points.Average(p => p.Y);

        double covariance = points.Sum(p => (p.X - meanX) * (p.Y - meanY)) / (n - 1);

        return covariance;
    }
}



public class GraphPlotter
{
    private double _maxX;
    private double _maxY;
    private double _canvasWidth;
    private double _canvasHeight;
    private Canvas _canvas;

    public GraphPlotter(double maxX, double maxY, double canvasWidth, double canvasHeight)
    {
        _maxX = maxX;
        _maxY = maxY;
        _canvasWidth = canvasWidth;
        _canvasHeight = canvasHeight;
        _canvas = new Canvas
        {
            Width = canvasWidth,
            Height = canvasHeight,
            Background = Brushes.White
        };
    }

    private double NormalizeX(double x)
    {
        return (x / _maxX) * _canvasWidth;
    }

    private double NormalizeY(double y)
    {
        return _canvasHeight - (y / _maxY) * _canvasHeight; // Inverterar y-värdet för att passa Canvasens koordinatsystem
    }

    public Canvas UpdatePlot(List<Vector2D> pointsOne, List<Vector2D> pointsTwo, List<Vector2D> pointsThree, List<Vector2D> pointsFour)
    {
        // Sätt startindex för att endast rita nya punkter
        int startIndex1 = _canvas.Children.Count / 4;
        int startIndex2 = startIndex1;
        int startIndex3 = startIndex1;
        int startIndex4 = startIndex1;

        // Rita nya punkter för varje lista
        DrawPoints(pointsOne, startIndex1, Brushes.Red);
        DrawPoints(pointsTwo, startIndex2, Brushes.Green);
        DrawPoints(pointsThree, startIndex3, Brushes.Blue);
        DrawPoints(pointsFour, startIndex4, Brushes.Purple);

        return _canvas;
    }

    private void DrawPoints(List<Vector2D> points, int startIndex, Brush color)
    {
        for (int i = startIndex; i < points.Count; i++)
        {
            var point = points[i];
            double x = NormalizeX(point.X);
            double y = NormalizeY(point.Y);

            var ellipse = new Ellipse
            {
                Width = 4,
                Height = 4,
                Fill = color
            };

            Canvas.SetLeft(ellipse, x - 2);
            Canvas.SetTop(ellipse, y - 2);

            _canvas.Children.Add(ellipse);
        }
    }
}
