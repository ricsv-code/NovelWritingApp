        public class UnscentedKalmanFilter
        {
            private double _state; // State (e.g., position)
            private double _errorCovariance; // Error covariance (uncertainty in state)
            private readonly double _processNoise;
            private readonly double _measurementNoise;

            //Sigma Points Generation: The GenerateSigmaPoints function creates sigma points that represent the distribution of the state.

            //Unscented Transform: Sigma points are transformed through the process and measurement models, and the predicted mean and covariance are calculated.

            //Kalman Gain: It calculates the Kalman Gain using the cross-covariance between the state and the measurement.

            // State Update: The state and covariance are updated based on the measurement using the Kalman Gain.

            public UnscentedKalmanFilter(double initialState, double initialErrorCovariance, double processNoise, double measurementNoise)
            {
                _state = initialState;
                _errorCovariance = initialErrorCovariance;
                _processNoise = processNoise;
                _measurementNoise = measurementNoise;
            }


            public Func<double, double> ProcessModel { get; set; }
            public Func<double, double> MeasurementModel { get; set; }

            public double Update(double measurement)
            {
                // Generate sigma points
                double[] sigmaPoints = GenerateSigmaPoints(_state, _errorCovariance);

                // Predict sigma points
                double[] predictedSigmaPoints = new double[sigmaPoints.Length];
                for (int i = 0; i < sigmaPoints.Length; i++)
                {
                    predictedSigmaPoints[i] = ProcessModel(sigmaPoints[i]);
                }

                // Calculate predicted mean and covariance
                double predictedMean, predictedCovariance;
                CalculateMeanAndCovariance(predictedSigmaPoints, out predictedMean, out predictedCovariance);

                // Add process noise
                predictedCovariance += _processNoise;

                // Transform sigma points through measurement model
                double[] measurementSigmaPoints = new double[sigmaPoints.Length];
                for (int i = 0; i < sigmaPoints.Length; i++)
                {
                    measurementSigmaPoints[i] = MeasurementModel(predictedSigmaPoints[i]);
                }

                // Calculate predicted measurement mean and covariance
                double predictedMeasurementMean, predictedMeasurementCovariance;
                CalculateMeanAndCovariance(measurementSigmaPoints, out predictedMeasurementMean, out predictedMeasurementCovariance);

                // Add measurement noise
                predictedMeasurementCovariance += _measurementNoise;

                // Calculate cross covariance between state and measurement
                double crossCovariance = 0;
                for (int i = 0; i < sigmaPoints.Length; i++)
                {
                    crossCovariance += (predictedSigmaPoints[i] - predictedMean) * (measurementSigmaPoints[i] - predictedMeasurementMean);
                }
                crossCovariance /= sigmaPoints.Length;

                // Calculate Kalman Gain
                double kalmanGain = crossCovariance / predictedMeasurementCovariance;

                // Update state and covariance with the measurement
                _state = predictedMean + kalmanGain * (measurement - predictedMeasurementMean);
                _errorCovariance = predictedCovariance - kalmanGain * crossCovariance * kalmanGain;

                return _state;
            }

            private double[] GenerateSigmaPoints(double state, double covariance)
            {
                double sqrtCovariance = Math.Sqrt(covariance);
                return new double[] { state, state + sqrtCovariance, state - sqrtCovariance };
            }

            private void CalculateMeanAndCovariance(double[] points, out double mean, out double covariance)
            {
                mean = 0;
                covariance = 0;

                for (int i = 0; i < points.Length; i++)
                {
                    mean += points[i];
                }
                mean /= points.Length;

                for (int i = 0; i < points.Length; i++)
                {
                    covariance += (points[i] - mean) * (points[i] - mean);
                }
                covariance /= points.Length;
            }
        }
