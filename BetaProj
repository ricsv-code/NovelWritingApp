public class PlateauDetector : IPlateauDetector
{
    public double MinPlateauLength { get; set; }
    public double PlateauStartMinX { get; set; }
    public double PlateauMinY { get; set; }
    public bool XFlipped { get; set; }
    public bool YFlipped { get; set; }

    private List<Vector2> _points;
    private Vector2 _currentPlateauStart;

    public PlateauDetector()
    {
        _points = new List<Vector2>();
        _currentPlateauStart = Vector2.Zero;
    }

    public bool Update(Vector2 newPoint, out Vector2 startOfPlateau)
    {
        // Lägg till den nya punkten till listan av punkter
        _points.Add(newPoint);

        // Om vi har tillräckligt många punkter, beräkna kovariansen
        if (_points.Count >= 2)
        {
            double covariance = CalculateCovariance(_points);

            // Kontrollera om kovariansen är nära noll, vilket skulle indikera en platå
            if (Math.Abs(covariance) < 0.001) // Threshold för att detektera platå
            {
                // Kontrollera om x-intervallet är tillräckligt stort för att vara en platå
                if (Math.Abs(_points.Last().X - _points.First().X) >= MinPlateauLength &&
                    _points.First().X >= PlateauStartMinX &&
                    _points.All(p => p.Y >= PlateauMinY))
                {
                    startOfPlateau = _currentPlateauStart = _points.First();
                    return true;
                }
            }
        }

        startOfPlateau = Vector2.Zero;
        return false;
    }

    public void Reset()
    {
        _points.Clear();
        _currentPlateauStart = Vector2.Zero;
    }

    private double CalculateCovariance(List<Vector2> points)
    {
        int n = points.Count;
        double meanX = points.Average(p => p.X);
        double meanY = points.Average(p => p.Y);

        double covariance = points.Sum(p => (p.X - meanX) * (p.Y - meanY)) / (n - 1);

        return covariance;
    }
}
